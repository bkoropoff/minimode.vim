let s:overrides = get(s:, 'overrides', {})

function! s:CompileAction(action)
    let compiled = {}
    let Action = a:action
    if type(Action) == v:t_string
        let Action = {'exec': Action}
    elseif type(Action) == v:t_func
        let Action = {'call': Action}
    endif
    let compiled.exit = get(Action, 'exit', 0)
    let compiled.hidden = get(Action, 'hidden', 0)
    if has_key(Action, 'call')
        let compiled.call = Action.call
    elseif has_key(Action, 'map')
        let rhs = Action.map
        let compiled.call = {-> feedkeys(rhs, 'im')}
    elseif has_key(Action, 'noremap')
        let rhs = Action.map
        let compiled.call = {-> feedkeys(rhs, 'in')}
    else
        let cmd = get(Action, 'exec', '')
        let compiled.call = {-> execute(cmd)}
    endif
    if has_key(Action, 'name')
        let compiled.name = Action.name
    endif
    return compiled
endfunction

function! s:Message(mode)
    let msg = '['.a:mode.name.'] '
    for [k, v] in items(a:mode.actions)
        if v.hidden
            continue
        endif
        if has_key(v, 'name')
            let msg .= k.': '.v.name.' | '
        else
            let msg .= k.' | '
        endif
    endfor
    return msg[0:-4]
endfunction

function! s:GetChar()
    let c = getchar()
    while c == "\<CursorHold>"
        let c = getchar()
    endwhile
    return type(c) == v:t_number ? nr2char(c) : c
endfunction

" Run the given minimode from minimode#compile()
"
" Displays a status message for the mode and begins interpreting keypresses.
" The mode will be exited if an unhandled key is pressed (in which case the
" key will produce its usual behavior), or if executing an action marked as
" exiting.
function! minimode#run(mode)
    let exit = 0
    let pos = 0
    let status = {}

    try
        let res = a:mode.enter.call()
        if type(res) == v:t_dict
            let status = res
        endif

        while !exit
            echohl ModeMsg
            echon a:mode.message
            echohl NONE
            if status != {}
                echon ' '
                exec 'echohl' status.hl
                echon '['.status.text.']'
                echohl NONE
                let status = {}
            endif
            echo

            let pos = matchaddpos('Cursor', [getpos('.')[1:2]])
            redraw

            let c = s:GetChar()

            call matchdelete(pos)
            let pos = 0

            let action = get(a:mode.actions, c, {})
            if action == {}
                call feedkeys(c, 'ti')
                break
            endif

            let exit = action.exit
            let res = action.call()
            if type(res) == v:t_dict
                let status = res
            endif
        endwhile

        echon
    catch
        echohl ErrorMsg
        echom substitute(v:exception, '^[^:]*:', '', '')
        echohl None
    finally
        if pos
            call matchdelete(pos)
        endif

        call a:mode.leave.call()
    endtry
endfunction

function! s:Override(dict, ov)
    let dict = copy(a:dict)
    for [k, V] in items(a:ov)
        let nk = k
        if type(V) == v:t_dict
            if len(V) == 1 && has_key(V, '<override>')
                let [nk, V] = call(V['<override>'], [get(dict, k, v:null)])
            elseif has_key(dict, k)
                let V = s:Override(dict[k], V)
            endif
        endif
        if has_key(dict, k)
            call remove(dict, k)
        endif
        if V isnot v:null
            let dict[nk] = V
        endif
    endfor
    return dict
endfunction

" Compile a minimode for use with minimode#run()
"
" Mode format:
" {
" \    'name': '<minimode name>'
" \    'enter': <action>,
" \    'leave': <action>,
" \    'message': <cmdline status message>,
" \    'actions': {
" \       '<key>': <action>,
" \       ...
" \    }
" \}
"
" The 'enter' and 'leave' actions are run upon entering and leaving the
" minimode.
"
" If 'message' is not provided, one will be generated from the mode name and
" action names.
"
" Action format:
" {
" \    'name': '<name in help message>',
" \    'call': <funcref>,
" \    'exit': 0 | 1,
" \    'hidden': 0 | 1
" \}
"
" An action with 'exit' of 1 will exit the minimode after running.
"
" A 'hidden' action will not be included in the autogenerated status message.
"
" As a convenience, the following dict keys can be used instead of 'call':
" - 'exec': An ex command to run
" - 'map': A key sequence (with recursive mapping)
" - 'noremap': A key sequence (without recursive mapping)
"
" If the entire action is a funcref instead of a dict, it is like using the
" 'call' key.
"
" If the entire action is a string, it is like using the 'exec' key.
"
" Note that the key sequences of the 'map' and 'noremap' will received by
" interpreted by the current minimode if the action does not exit.
"
" An action function may return an additional message to append to the
" cmdline area in the following form:
"
" {'text': <text to display>, 'hl': <highlight group>}
"
" This is useful for displaying error messages without terminating the
" minimode.
function! minimode#compile(mode)
    let compiled = {}
    let mode = a:mode
    if !has_key(mode, 'name')
        throw 'minimode: mode must have a name'
    endif
    let ov = get(s:overrides, mode.name, {})
    if ov != {}
        let mode = s:Override(mode, ov)
    endif
    let compiled.name = mode.name
    let compiled.enter = s:CompileAction(get(mode, 'enter', {}))
    let compiled.leave = s:CompileAction(get(mode, 'leave', {}))
    let actions = {}
    for [k, v] in items(get(mode, 'actions', {}))
        let actions[k] = s:CompileAction(v)
    endfor
    let compiled.actions = actions
    if has_key(mode, 'message')
        let compiled.message = mode.message
    else
        let compiled.message = s:Message(compiled)
    endif
    return compiled
endfunction

" Register minimode override
"
" A minimode *subsequently* compiled with the same name will have its dict 
" keys recursively overwritten with those of the override.  Useful to allow
" the user to extend minimodes from plugins.
"
" To remove a key, use v:null as the value.
"
" To arbitrarily transform a key, use { '<override>': <funcref> } as a value.
" It will be called with the existing value (v:null if missing from the
" minimode) as an argument.  It should return a [<newkey>, <newvalue>] pair to
" replace the existing pair in the minimode.  Among other things, this can be
" used to override the key associated with an action, e.g. to remap an x
" keypress to y:
"
" 'x': {'<override>': {v -> ['y', v]}}
"
" This pattern is captured by the minimode#remap_to() function:
"
" 'x': minimode#remap_to('y')
function! minimode#override(mode)
    if !has_key(a:mode, 'name')
        throw 'minimode: override must have a name'
    endif
    let s:overrides[a:mode.name] = a:mode
endfunction

" Unregister minimode override
function! minimode#unoverride(name)
    if has_key(s:overrides, a:name)
        unlet s:overrides[a:name]
    endif
endfunction

" Shorthand for an action override that just changes the keypress
function! minimode#remap_to(k)
    return {'<override>': {v -> [a:k, v]}}
endfunction

" Shorthand for a (hidden) action that aliases another
function! minimode#alias(k)
    return {'hidden': 1, 'map': a:k}
endfunction
